package com.ujs.innerclass;

/**
 * 内部类
 * @author SUN
 *	https://blog.csdn.net/hacker_zhidian/article/details/82193100
 */
public class TestInnerClass {
	public static void main(String[] args) {
		StaticInnerClassTest mStaticInnerClassTest = new StaticInnerClassTest();
	}
}

/**
 * 
1.普通内部类
	内部类对象可以访问外部类对象中所有访问权限的字段，同时，外部类对象也可以通过内部类的对象引用来访问
内部类中定义的所有访问权限的字段。
2.静态内部类

3.匿名内部类

4.局部内部类


内部类的嵌套:
内部类的嵌套，即为内部类中再定义内部类，这个问题从内部类的分类角度去考虑比较合适：
普通内部类：在这里我们可以把它看成一个外部类的普通成员方法，在其内部可以定义普通内部类（嵌套的普通内部类），但是无法定义 static 修饰的内部类，就像你无法在成员方法中定义 static 类型的变量一样，当然也可以定义匿名内部类和局部内部类；

静态内部类：因为这个类独立于外部类对象而存在，我们完全可以将其拿出来，去掉修饰它的 static 关键字，他就是一个完整的类，因此在静态内部类内部可以定义普通内部类，也可以定义静态内部类，同时也可以定义 static 成员；

匿名内部类：和普通内部类一样，定义的普通内部类只能在这个匿名内部类中使用，定义的局部内部类只能在对应定义域内使用；

局部内部类：和匿名内部类一样，但是嵌套定义的内部类只能在对应定义域内使用。

内存泄露：即指在内存中存在一些其内存空间可以被回收的对象因为某些原因又没有被回收，因此产生了内存泄露，
如果应用程序频繁发生内存泄露可能会产生很严重的后果（内存中可用的空间不足导致程序崩溃，甚至导致整个系统
卡死）。

如何避免内存泄漏：
	1.能用静态内部类就尽量使用静态内部类;
	2.对于一些自定义类的对象，慎用 static 关键字修饰（除非这个类的对象的声明周期确实应该很长）;
	3.为某些组件（大型）提供一个当这个大型组件需要被回收的时候用于合理处理其中的一些小组件的方法;

*/